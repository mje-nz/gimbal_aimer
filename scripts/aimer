#!/usr/bin/env python
# coding: utf-8
"""Single-axis gimbal aimer node.

Subscribes to a PointStamped topic, transforms the point into the gimbal's (non-rotatin) tf frame, then publishes a
JointState message (for joint_state_publisher) which aims the gimbal at the point.

An angle of zero is horizontal, positive is up, negative is down.
"""

from __future__ import print_function

import copy
import math

import rospy
from geometry_msgs.msg import Point, PointStamped
from sensor_msgs.msg import JointState
from mavros_msgs.msg import MountControl
import tf


class AimerNode(object):

    def __init__(self):
        self.gimbal_frame = rospy.get_param('gimbal_frame', 'gimbal_link')
        self.joint_name = rospy.get_param('gimbal_joint', 'payload_joint')
        self.tf_listener = tf.TransformListener()
        self.point_listener = rospy.Subscriber('point', PointStamped, self.point_callback)

        self.min_angle = math.radians(rospy.get_param('~min_angle', -90))
        self.max_angle = math.radians(rospy.get_param('~max_angle', 90))

        self.joint_state_pub = None
        if rospy.get_param('~publish_joint_state', True):
            self.joint_state_pub = rospy.Publisher('~joint_state', JointState, queue_size=1)

        self.mount_control_pub = None
        if rospy.get_param('~control_gimbal', True):
            self.mount_control_pub = rospy.Publisher('~mount_control', MountControl, queue_size=1)

        print('Ready')

    def _transform_point(self, point_message):
        try:
            # Use most recent tf available (otherwise, if the point is newer than the tf transformPoint errors)
            t = self.tf_listener.getLatestCommonTime(self.gimbal_frame, point_message.header.frame_id)
            point_message_copy = copy.copy(point_message)
            point_message_copy.header.stamp = t

            point_transformed = self.tf_listener.transformPoint(self.gimbal_frame, point_message_copy).point  # type: Point
            return point_transformed
        except tf.Exception:
            return None

    def _should_control(self, transformed_point):
        """Decide whether we're close enough to start aiming."""
        p = transformed_point
        close_enough = (p.x**2 + p.y**2 + p.z**2) <= 1
        if not close_enough:
            print('Not close enough')
        in_front_of = p.x > 0
        if not in_front_of:
            print('Not in front of')
        return close_enough and in_front_of

    def point_callback(self, point_message):
        transformed_point = self._transform_point(point_message)
        if transformed_point is None:
            print('Could not transform point')
            return

        if not self._should_control(transformed_point):
            return

        angle = math.atan2(transformed_point.z, transformed_point.x)
        print('Angle:', angle)

        angle = max(min(angle, self.max_angle), self.min_angle)

        if self.joint_state_pub:
            joint_state_message = JointState()
            joint_state_message.header = point_message.header
            joint_state_message.name = [self.joint_name]
            joint_state_message.position = [angle]
            self.joint_state_pub.publish(joint_state_message)

        if self.mount_control_pub:
            mount_control_message = MountControl()
            mount_control_message.mode = MountControl.MODE_MAVLINK_TARGETING
            mount_control_message.pitch = math.degrees(angle)


if __name__ == '__main__':
    rospy.init_node('gimbal_aimer')
    node = AimerNode()
    rospy.spin()
    print('Exiting')
