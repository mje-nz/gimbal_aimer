#!/usr/bin/env python
# coding: utf-8
"""Single-axis gimbal aimer node.

Subscribes to a PointStamped topic, transforms the point into the gimbal's (non-rotatin) tf frame, then publishes a
JointState message (for joint_state_publisher) which aims the gimbal at the point.
"""

from __future__ import print_function

import copy
import math

import rospy
from geometry_msgs.msg import Point, PointStamped
from sensor_msgs.msg import JointState
from mavros_msgs.msg import MountControl
import tf


class AimerNode(object):

    def __init__(self):
        self.gimbal_frame = rospy.get_param('gimbal_frame', 'gimbal_link')
        self.joint_name = rospy.get_param('gimbal_joint', 'payload_joint')
        self.tf_listener = tf.TransformListener()
        self.point_listener = rospy.Subscriber('point', PointStamped, self.point_callback)

        self.joint_state_pub = None
        if rospy.get_param('~publish_joint_state', True):
            self.joint_state_pub = rospy.Publisher('~joint_state', JointState, queue_size=1)

        self.mount_control_pub = None
        if rospy.get_param('~control_gimbal', True):
            self.mount_control_pub = rospy.Publisher('~mount_control', MountControl, queue_size=1)

        print('Ready')

    def _transform_point(self, point_message):
        try:
            # Use most recent tf available (otherwise, if the point is newer than the tf transformPoint errors)
            t = self.tf_listener.getLatestCommonTime(self.gimbal_frame, point_message.header.frame_id)
            point_message_copy = copy.copy(point_message)
            point_message_copy.header.stamp = t

            point_transformed = self.tf_listener.transformPoint(self.gimbal_frame, point_message_copy).point  # type: Point
            return point_transformed
        except tf.Exception:
            return None

    def point_callback(self, point_message):
        point_transformed = self._transform_point(point_message)
        if point_transformed is None:
            print('Could not transform point')
            return
        angle = math.atan2(point_transformed.z, point_transformed.x)
        print('Angle:', angle)

        if self.joint_state_pub:
            joint_state_message = JointState()
            joint_state_message.header = point_message.header
            joint_state_message.name = [self.joint_name]
            joint_state_message.position = [angle]
            self.joint_state_pub.publish(joint_state_message)

        if self.mount_control_pub:
            mount_control_message = MountControl()
            mount_control_message.mode = MountControl.MODE_MAVLINK_TARGETING
            mount_control_message.pitch = math.degrees(angle)


if __name__ == '__main__':
    rospy.init_node('gimbal_aimer')
    node = AimerNode()
    rospy.spin()
    print('Exiting')
